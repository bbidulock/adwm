.Dd @MDOCDATE@
.Dt @PACKAGE_NAME@-KEYS \&5 "File Formats"
.Os @PACKAGE_STRING@
.Sh NAME
.Nm @PACKAGE@-keys
.Nd advanced dynamic window manager for X: key bindings
.Sh SYNOPSIS
.Bl -item -compact
.It
.Cm $(dirname <themeFile>) Ns Pa /keysrc
.It
.Cm $(dirname <styleFile>) Ns Pa /keysrc
.It
.Cm ${ADWMPRIVDIR} Ns Pa /keysrc
.It
.Cm ${XDG_RUNTIME_DIR} Ns Pa /@PACKAGE@/keysrc
.It
.Cm ${XDG_CONFIG_HOME} Ns Pa /@PACKAGE@/keysrc
.It
.Cm ${HOME} Ns Pa /.@PACKAGE@/keysrc
.It
.Pa @pkgconfdir@/keysrc
.El
.Sh DESCRIPTION
.Nm @PACKAGE_NAME@
is a light-weight, reparenting, dynamic tiling/stacking window
manager intended on being fully controllable using only the
keyboard: the objective of all dynamic tiling window managers.
To acheive this objective,
.Nm @PACKAGE_NAME@
supports both simple single-press key bindings as well as key chains.
.Pp
Single key bindings are key bindings on the root window that perform some action in
response to a single key press.  Key chaining is when an Emacs-like sequence of keys
need to be pressed for the action to be performed.
.Pp
Key bindings are defined in an X Resource formatted configuration file.
Key bindings can either being part of the main configuration file, or
they can be included or referenced from the main configuration file: see the
.Cm keysFile
directive in
.Xr @PACKAGE@-config 5 .
It is typical to place the key binding in a file named
.Pa keysrc
in the same directory as the main configuration file (e.g. in the
.Pa "~/.@PACKAGE@/keysrc"
file).  See
.Sx FILES ,
below.
.Sh SYNTAX
.Pp
The general syntax of key commands, as specified directly in the
.Nm @PACKAGE_NAME@
resource file, is as follows:
.Pp
.Dl Li "Adwm*" Ns Cm command Ns Li : Ar <list>
.Pp
where the fields are defined as follows:
.Pp
.Bl -tag -width Ds
.It Cm command
One of the commands described under
.Sx COMMANDS .
.It Ar <list> Li = Ar <binding> Op Li , Ar ...
A list of one or more key values, separated by commas.
The list represents the list of key bindings associated with the
.Cm command .
Each
.Ar <binding>
in the list represents a single key binding to the
.Cm command
with arguments.
.It Ar <binding> Li = Ar <chain> Op Li = Ar <args>
A key chain followed by an optional equal-sign and key arguments list.
The
.Ar <chain>
specifies the sequence of key presses necessary to invoke the
.Cm command ,
and the
.Ar <args>
specify the arguments to
.Cm command
that are associated with this key binding, described for each
.Cm command ,
below, under
.Sx COMMANDS .
.It Ar <args> Li = Ar <arg> Ns Op Li " " Ar ...
A list of key arguments separated by spaces.  Individual key arguments cannot contain
the comma, colon nor space characters.
.It Ar <chain> Li = Ar <spec> Op Li : Ar ...
A list of one or more key specifications, separated by colons.  Each
.Ar <spec>
specifies a keypress combination that must be performed in sequence to cause the
.Cm command
action to be performed.
.Pp
Example:
.Ar "W + w : h"
.It Ar <spec> Li = [ Ns Ar <modifiers> Li "+ ]" Ns Ar <symbol>
An optional set of modifiers and a plus-sign, followed by a key symbol.
The
.Ar <symbol>
is the name of the key symbol;
.Ar <modifiers>
is a string containing one or more of the following characters:
.Pp
.Bl -tag -width ".Li M" -compact
.It Li A
The
.Li Alt
key.
.It Li C
The
.Li Control
key.
.It Li S
The
.Li Shift
key.
.It Li W
The
.Li Super (Windows)
key.
.It Li M
The
.Li Mod
key.  This key is definable using the
.Cm modkey
resource and defaults to the
.Li Alt
key.
.It Li N
The not
.Li Mod
key.  When
.Cm modkey
is defined to
.Li A ,
this is the same as
.Li W ;
otherwise, the other way around.
.El
.Pp
Default:
.Li Adwm* Ns Cm modkey Ns : Ar "A"
.El
.Pp
Note that whitespace is optional (except in the arguments list where arguments are
separated by spaces).
.Pp
The following is an example of vim-like window key movement key chains:
.Pp
.Dl "Adwm*" Ns Cm movetoW Ns Li : Ar "W+w:h, CS+w:h"
.Dl "Adwm*" Ns Cm movetoN Ns Li : Ar "W+w:j, CS+w:j"
.Dl "Adwm*" Ns Cm movetoS Ns Li : Ar "W+w:k, CS+w:k"
.Dl "Adwm*" Ns Cm movetoE Ns Li : Ar "W+w:l, CS+w:l"
.Sh COMMANDS
There is one command that is used to set the modifier key; four commands
that are used with preset mouse bindings; and, the remainder are for use
with key bindings.  The commands are described below.  Each heading
provides the format of the command resource (without the
.Li "Adwm*"
portion) and the possible arguments to each mouse binding.
.Ss MOD KEY
There is one command to set the modifier key.
.Pp
.Bl -tag -width "XX"
.It Cm modkey Li { Ns Ar A Ns Li | Ns Ar W Ns Li }
This sets the sense of
the
.Ic M
and
.Ic N
key modifier specifications.  When set to
.Ic 'A' ,
.Ic M
is
.Ic A
and
.Ic N
is
.Ic W;
when set to
.Ic 'W' ,
.Ic M
is
.Ic W
and
.Ic N
is
.Ic A .
.Pp
Default:
.Li Adwm* Ns Cm modkey Ns Li : Ar A
.El
.Ss MOUSE BINDINGS
There are four commands that are used with preset mouse bindings
(clicking on root window, titlebar or menu button).  The commands are
described below.
.Pp
Mouse directive apply to button pressed on the root window or
menu button on a client window title bar.  It is possible to
specify different commands to execute based upon the screen on
which the button is clicked by using the
.Li Op Cm screen<s>.
syntax (where
.Cm <s>
is the number of the screen indexed from zero).
.Bl -tag -width "XX"
.It Li [ Ns Cm screen<s>. Ns Li ] Ns Cm command Ar <shell-command>
Specifies the shell command to execute when button 3 (right
button) is pressed on the root window.
The default, when unspecified, is
.Li "\(lqxterm\(rq" .
(The default is consistent with the behaviour of many tiling
window managers, as most dynamic window managers do not
support a root menu.)
See
.Xr xde-menu 1
for a suitable root window menu for
.Cm @PACKAGE@ .
.Pp
Default:
.Li Adwm* Ns Cm command Ns Li : Ar "xde-menu -P -b 3"
.It Li [ Ns Cm screen<s>. Ns Li ] Ns Cm command2 Ar <shell-command>
Specifies the shell command to execute when button 2 (middle
button) is pressed on the root window.
The default is to not execute a shell command.
See
.Xr xde-wkspmenu 1
for a suitable workspace menu for
.Cm @PACKAGE@ .
.Pp
Default:
.Li Adwm* Ns Cm command2 Ns Li : Ar "xde-wkspmenu -p -b 2"
.It Li [ Ns Cm screen<s>. Ns Li ] Ns Cm command3 Ar <shell-command>
Specifies the shell command to execute when button 1 (left
button) is pressed on the root window.
The default is to not execute a shell command.
See
.Xr xde-winlist 1
for a suitable window list menu for
.Cm @PACKAGE@ .
.Pp
Default:
.Li "! Adwm*" Ns Cm command3 Ns Li : Ar "xde-winlist -p -b 1 --hidden"
.Pp
.Sy Note:
This command is commented out in the default
.Cm keysFile
because it can be quite annoying to bind button 1 on the root window.
.It Li [ Ns Cm screen<s>. Ns Li ] Ns Cm menucommand Ar <shell-command>
Specifies the shell command to execute when a button is
pressed on the \(lqmenu\(rq button in the title bar.
The default is to not execute a shell command.
See
.Xr xde-winmenu 1
for a suitable window menu for
.Cm @PACKAGE@ .
.Pp
Default:
.Li Adwm* Ns Cm menucommand Ns Li : Ar "xde-winmenu -p -b 1"
.El
.Ss KEY BINDINGS
The remaining commands are key bindings.  The commands are described
below.
Each heading provides the format of the command resource (without the
.Li "Adwm*"
portion) and the possible arguments to each key binding, in accordance
with the key binding sytnax described above under
.Sx SYNTAX .
.Bl -tag -width "XX"
.It Cm viewprevtag
.It Cm quit Op Ar shell-command
Causes
.Nm @PACKAGE_NAME@
to quit.
When
.Ar shell-command
is specified, executes
.Ar shell-command
instead of quitting.
.Pp
Default:
.Li Adwm* Ns Cm quit Ns Li : Ar "AC + p : End, AC + q, WS + q"
.It Cm restart Op Ar shell-command
Causes
.Nm @PACKAGE_NAME@
to restart.
When
.Ar shell-command
is specified, executes
.Ar shell-command
instead of restarting.
.Pp
Default:
.Li Adwm* Ns Cm restart Ns Li : Ar "AC + p : Next, AC + p : Prior = twm, AS + q, WC + r"
.It Cm reload
Causes
.Nm @PACKAGE_NAME@
to reload configuration files.
.Pp
Default:
.Li Adwm* Ns Cm reload Ns Li : Ar "AC + p : Delete"
.It Cm killclient
Closes the selected client.  The behaviour of
.Nm @PACKAGE_NAME@
when closing clients is to first attempt a close request to the client and upon the
next attempt, kills the client process if the process identifier of the client is
known, the client supports the
.Ev _NET_WM_PING
protocol, and has not responded to a ping since the latest attempt to close the
client.
.Pp
Default:
.Li Adwm* Ns Cm killclient Ns Li : Ar "A+F4, A+q, AC+a:q:f, AC+a:q:k, AC+a:q:q, AS+c, W+q, W+x, WS+c, WS+x"
.It Cm zoom
Zooms the selected client.  When in tile layout, and the selected client is a
master, this makes the first unselected slave client in the stacking area the current
master; when the selected client is in the stacking area, makes it the new master.
.Pp
Default:
.Li Adwm* Ns Cm zoom Ns Li : Ar "A + Return, W + Return, WC + Return"
.It Cm move<direction> Op Ar "dx dy dw dh"
Moves the selected client in the
.Cm <direction>
by the amounts specified.
.Pp
.Cm <direction>
can be one of:
.Pp
.Bl -tag -width ".Cm right" -compact
.It Cm right
Moves the selected client to the right.
.It Cm left
Moves the selected client to the left.
.It Cm up
Moves the selected client upward.
.It Cm down
Moves the selected client downward.
.El
.Pp
The optional arguments specify the movement and resize of the window and consists of
four positive or negative integers as follows:
.Pp
.Bl -tag -width ".Ar dw" -compact
.It Ar dx
offset to apply to the window x-coordinate position;
.It Ar dy
offset to apply to the window y-coordinate position;
.It Ar dw
number of pixels to add to the window width;
.It Ar dh
number of pixels to add to the window height.
.El
.Pp
Note that the practice of specifying more arguments than are necessary is for backward
compatibility.
.Pp
Defaults:
.Dl Adwm* Ns Cm moveright Ns Li ":" Ar "W + bracketright"
.Dl Adwm* Ns Cm moveleft Ns Li ": " Ar "W + bracketleft"
.Dl Adwm* Ns Cm moveup Ns Li ":   " Ar "WS + bracketleft"
.Dl Adwm* Ns Cm movedown Ns Li ": " Ar "WS + bracketright"
.It Cm resize<how><axis> Op Ar "dx dy dw dh"
Resizes the selected client by
.Cm <how>
along
.Cm <axis>
in the amounts specified.
.Pp
.Cm <how>
can be one of:
.Bl -tag -width ".Cm dec" -compact -offset indent
.It Cm dec
Decrease the size of the window.
.It Cm inc
Increase the size of the window.
.El
.Pp
.Cm <axis>
can be one of:
.Bl -tag -width ".Cm x" -compact -offset indent
.It Cm x
Resize the window horizontally.
.It Cm y
Resize the window vertically.
.El
.Pp
The optional arguments specify the movement and resize of the window and consists of
four positive or negative integers as follows:
.Bl -tag -width ".Ar dw" -compact -offset indent
.It Ar dx
offset to apply to the window x-coordinate position;
.It Ar dy
offset to apply to the window y-coordinate position;
.It Ar dw
number of pixels to add to the window width;
.It Ar dh
number of pixels to add to the window height.
.El
.Pp
.Sy Note:
The practice of specifying more arguments than are necessary is for backward
compatibility.
The default when unspecified is 5 pixels in the appropriate dimension.
.Pp
Defaults:
.Dl Adwm* Ns Cm resizedecx Ns Li : Ar "AC + a : Left,  AS + a, W +  minus"
.Dl Adwm* Ns Cm resizedecy Ns Li : Ar "AC + a : Down,  AS + s, WS + minus"
.Dl Adwm* Ns Cm resizeincx Ns Li : Ar "AC + a : Right, AS + d, W +  equal"
.Dl Adwm* Ns Cm resizeincy Ns Li : Ar "AC + a : Up,    AS + w, WS + equal"
.\" .It Cm begmove
.\" Begins a keyboard-based move of the selected window.  The arrow keys are used to move the window.
.\" Press escape to complete the move.
.\" .Pp
.\" Default:
.\" .Li Adwm* Ns Cm begmove Ns Li : Ar "A + F7, WS + m"
.\" .It Cm begsize
.\" Begins a keyboard-based resize of the selected window.  The arrow keys are used to resize the
.\" window.  Press escape to complete the resize.
.\" .Pp
.\" Default:
.\" .Li Adwm* Ns Cm begsize Ns Li : Ar "A + F8, AC + a : Return"
.\" .It Cm begmoveresize
.\" Begins a keyboard-based move and resize of the selected window.  The arrow keys are used to move the
.\" window.  The arrow keys with the control key held are used to resize the window.  Press escape to
.\" complete the move.
.\" .Pp
.\" Defaults:
.\" .Dl "! Adwm*" Ns Cm begmoveresize Ns Li : Ar "AC + a : Return"
.\" .Dl "! Adwm*" Ns Cm begmoveresize Ns Li : Ar "WS + m"
.\" .Pp
.\" .Sy Note:
.\" The defaults for
.\" .Cm begmoveresize
.\" are commented out in the default
.\" .Cm keyFile
.\" because of conflicts with keybindings of other functions.
.It Cm togglemonitor
Toggles the current monitor by warping the pointer to the its last position in the
next monitor from the current monitor and sets the keyboard focus to the last window
that was focused in that monitor.  If there is only one monitor, this does nothing.
.Pp
Default:
.Li "! Adwm*" Ns Cm togglemonitor Ns Li : Ar "A + grave"
.It Cm appendtag
Appends a new tag (workspace) to the list, increasing the number of desktops by one.
The maximum number of tags (workspaces) is set by configuration at 64.
.Pp
Default:
.Li Adwm* Ns Cm appendtag Ns Li : Ar "AC + equal"
.It Cm rmlasttag
Removes the last tag (workspace) from the list, decreasing the number of desktops by
one.  Any windows that were tagged only for the removed tag are tagged, instead, to
the last tag on the list.  The first tag (workspace) cannot be removed.
.Pp
Default:
.Li Adwm* Ns Cm rmlasttag Ns Li : Ar "AC + minus"
.\" .It Cm resetview
.\" Reset the view to its default settings for columns, rows, master width factor,
.\" orientation, etc.
.\" .Cm resetview
.\" is primarily for compatability with
.\" .Xr spectrwm 1 .
.\" .Pp
.\" Default:
.\" .Li Adwm* Ns Cm resetview Ns Li : Ar "WS + space"
.It Cm flipview Ns , Cm rotateview Ns , Cm unrotateview
Rotates (180-degrees, CW or CCW) the current view.  The view is the current tiling layout.  For
master-stacking area layouts, this means that the master zone rotates from rigth-stacking, to
bottom-stacking, to left-stacking, to top-stacking, and around again.
.Cm flipview
is primarily for compatability with
.Xr spectrwm 1 .
.Pp
Defaults:
.Dl Adwm* Ns Cm flipview Ns Li : Ar "WS + backslash"
.Dl Adwm* Ns Cm rotateview Ns Li : Ar "A + y"
.Dl Adwm* Ns Cm unrotateview Ns Li : Ar "AS + y"
.It Cm flipzone Ns , Cm rotatezone Ns , Cm unrotatezone
Rotates (180-degrees, CW or CCW) the current zone.  The zone is either the master, stacking, grid or
monocle area.
.Pp
Defaults:
.Dl Adwm* Ns Cm rotatezone Ns Li : Ar "AC + y"
.Dl Adwm* Ns Cm unrotatezone Ns Li : Ar "ACS + y"
.It Cm flipwins Ns , Cm rotatewins Ns , Cm unrotatewins
Rotates (180-degrees, CW or CCW) the windows in the current view.  That is, the windows rotate
through the current tiling positions, rather than the tiling positions rotating about the screen.
.Pp
Defaults:
.Dl Adwm* Ns Cm rotatewins Ns Li : Ar "A + e"
.Dl Adwm* Ns Cm unrotatewins Ns Li : Ar "AS + e"
.It Cm raise Ns , Cm lower Ns , Cm raiselower\" Ns , Cm raisetiled
Raises the selected window to the top of the stacking order; lowers the selected window to the
bottom of the stacking order; when the selected window is not on top, raise it to the top;
otherwise, lower it to the bottom.\" ; or raise tiled window over floating window.
.Pp
Defaults:
.Dl Adwm* Ns Cm raise Ns Li : Ar "A + Up, AC + a : S + r, AC + a : r"
.Dl Adwm* Ns Cm lower Ns Li : Ar "A + Down, AC + a : S + l, AC + a : l"
.Dl Adwm* Ns Cm raiselower Ns Li : Ar "A + Home, A + Left, AC + a : u"
.\" .Dl Adwm* Ns Cm raisetiled Ns Li : Ar "WS + r"
.It Cm <prefix><setting> Op [+-] Ns Ar value Ns [%]
Set, increment or decrment various view layout parameters.
.Pp
.Cm <prefix>
can be one of:
.Bl -tag -width ".Cm dec" -compact -offset indent
.It Cm set
Set the count or factor to
.Ar value Ns .
.It Cm inc
Increase the count or factor by
.Ar value Ns .
.It Cm dec
Decrease the count or factor by
.Ar value Ns .
.El
.Pp
.Cm <setting>
can be one of:
.Bl -tag -width ".Cm nmaster" -compact -offset indent
.It Cm mwfact
Set, increase or decrease the master width factor.  The default when factor is not specified is
to set the factor to
.Li 60% ,
or increase or decrease the factor by
.Li 5% .
.It Cm nmaster
Set, increase or decrease the number of masters when in tile mode.  The default when
number is not specified is to set the number to 1, or increase or decrease the
factory by 1.
.It Cm ncolumn
Set, increase or decrease the number of columns (or rows) in the stacking area when
in grid mode.  The default when number is not specified is to set the number to 1, or
increase or decrease the number by 1.
Note that this is an alias for
.Cm nmaster
and only one need be set (typically just
.Cm nmaster ).
.It Cm margin
Set, increase or decrease the margin between tiled windows in pixels.  The default when
number is not specified is to set the number to 0, or increase or decrease the number by 1.
.It Cm border
Set, increase or decrease the border around decorated windows in pixels.  The default when
number is not specified is to set the number to the value set by the style, or increase or
decrease the number by 1.
.El
.Pp
Defaults:
.Dl Adwm* Ns Cm decmwfact Ns Li : Ar "A + h, W + h"
.Dl Adwm* Ns Cm incmwfact Ns Li : Ar "A + l, W + l"
.Dl Adwm* Ns Cm decnmaster Ns Li : Ar "AS + j, W + period, WS + l"
.Dl Adwm* Ns Cm incnmaster Ns Li : Ar "AS + k, W + comma, WS + h"
.Dl Adwm* Ns Cm decncolumns Ns Li : Ar "WC + l, WS + period"
.Dl Adwm* Ns Cm incncolumns Ns Li : Ar "WC + h, WS + comma"
.Dl Adwm* Ns Cm decmargin Ns Li : Ar "WAS + m"
.Dl Adwm* Ns Cm incmargin Ns Li : Ar "WA + m"
.Dl Adwm* Ns Cm decborder Ns Li : Ar "WAS + b"
.Dl Adwm* Ns Cm incborder Ns Li : Ar "WA + b"
.It Cm [<prefix>]<state>[<suffix>] [0|1]
Changes the state of corresponding windows or layouts.
.Pp
The
.Cm <state>
indicates which state to change and is one of:
.Bl -tag -width ".Cm floating" -compact -offset indent
.It Cm floating
The window is floating (or tiled).
.It Cm fill
The window fills the available area.
.It Cm full
The window is fullscreen.
.It Cm max
The window is maximized.
.It Cm maxv
The window is vertically maximized.
.It Cm maxh
The window is horizontally maximized.
.It Cm lhalf
The window is left-halved.
.It Cm rhalf
The window is right-halved.
.It Cm shade
The window is shaded.
.It Cm shaded
The window is shaded.
.It Cm hide
The window is hidden.
.It Cm hidden
The window is hidden.
.It Cm iconify
The window is iconified (minimized).
.It Cm min
The window is iconified (minimized).
.It Cm above
The window is placed above others.
.It Cm below
The window is placed below others.
.It Cm pager
The window appears in the pager.
.It Cm taskbar
The window appears on the taskbar.
.It Cm sticky
The window is sticky.
.Pp
.It Cm showing
The layout is showing the desktop.
.It Cm struts
The layout is showing panels/docks.
.It Cm dectiled
The layout decorates tiled windows.
.El
.Pp
The optional
.Cm <prefix>
indicates whether to set, unset or toggle the state and is one of (defaulting to
.Cm set Ns ):
.Bl -tag -width ".Cm toggle" -compact -offset indent
.It Cm set
Sets the state.
.It Cm un
Unsets the state.
.It Cm de
Unsets the state.
.It Cm unset
Unsets the state.
.It Cm toggle
Toggles the state.
.El
.Pp
The optional
.Cm <suffix>
indicates to which windows or layouts the setting applies and is one of (defaulting
to
.Cm sel Ns ):
.Bl -tag -width ".Cm every" -compact -offset indent
.It Cm sel
The current window or layout.
.It Cm ptr
The window or layout under the pointer.
.It Cm all
All windows or layout on current monitor.
.It Cm other
All other windows or layouts on current monitor.
.It Cm any
All windows or layouts on any monitor.
.It Cm every
All windows or layouts.
.El
.Pp
Defaults:
.Dl Adwm* Ns Cm togglefloating Ns Li : Ar "AS + space, W + t, WC + space"
.Dl Adwm* Ns Cm togglefill Ns Li : Ar "AC + a : g : g, CS + Down"
.Dl Adwm* Ns Cm togglefillh Ns Li : Ar "AC + a : g : h"
.Dl Adwm* Ns Cm togglefillv Ns Li : Ar "AC + a : g : v"
.Dl Adwm* Ns Cm togglefull Ns Li : Ar "A + F11, AC + a : f, W + f"
.Dl Adwm* Ns Cm togglemaxv Ns Li : Ar "AC + a : m : v, AS + F10, CS + Up"
.Dl Adwm* Ns Cm togglemaxh Ns Li : Ar "AC + a : m : h, CS + Right"
.Dl Adwm* Ns Cm togglemax Ns Li : Ar "A + F10, AC + a : m : m, CS + Left, W + m, WA + Up"
.Dl Adwm* Ns Cm unmax Ns Li : Ar "A + F5, WC + n"
.Dl Adwm* Ns Cm togglelhalf Ns Li : Ar "WA + Left"
.Dl Adwm* Ns Cm togglerhalf Ns Li : Ar "WA + Right"
.Dl Adwm* Ns Cm toggleshade Ns Li : Ar "A + F12, A + s, AC + a : s"
.Dl Adwm* Ns Cm hide Ns Li : Ar "AS + F12, AS + h"
.Dl Adwm* Ns Cm hideall Ns Li : Ar "AS + F11"
.Dl Adwm* Ns Cm togglehidden Ns Li : Ar "WA + Down"
.Dl Adwm* Ns Cm iconify Ns Li : Ar "A + F9, AS + m, W + i, W + n, W + w"
.Dl Adwm* Ns Cm iconifyall Ns Li : Ar "AS + F9"
.Dl Adwm* Ns Cm uniconify Ns Li : Ar "WS + w"
.Dl Adwm* Ns Cm toggleabove Ns Li : Ar "A + Right, AC + a : o"
.Dl Adwm* Ns Cm togglebelow Ns Li : Ar "AC + a : b"
.Dl Adwm* Ns Cm toggleselect Ns Li : Ar "W + z"
.Dl Adwm* Ns Cm togglesticky Ns Li : Ar "AC + a : a, AC + s"
.Pp
.Dl Adwm* Ns Cm toggleshowing Ns Li : Ar "AC + d, W + d"
.Dl Adwm* Ns Cm togglestruts Ns Li : Ar "A + b, AC + p : h, AC + space, WS + b"
.Dl Adwm* Ns Cm togglestrutsall Ns Li : Ar "W + b"
.Dl Adwm* Ns Cm toggledectiled Ns Li : Ar "A + d"
.It Cm <movement><suffix> Op Ar increment
Moves windows around the workspace or between workspaces, or resizes windows within the workspace.
.Pp
.Cm <movement>
indicates the type of movement to perform and is one of:
.Bl -tag -width ".Cm moveby" -compact -offset indent
.It Cm moveto
Moves the window to the corresponding position in a 3x3 grid.
.It Cm snapto
Moves the window toward the corresponding position in a 3x3 grid, stopping at the first
obstacle.
.It Cm edgeto
Moves the window to the corresponding edges.
.It Cm moveby
Moves the window in the corresponding direction by the specified increment (or 1 when no default
increment is specified).
.El
.Pp
.Cm <suffix>
indicates the position or direction to which to move and
is one of the following:
.Bl -tag -width ".Cm SW" -compact -offset indent
.It Cm NW
The upper-left corner of the monitor.
.It Cm N
The upper edge of the monitor.
.It Cm NE
The upper-right corner of the monitor.
.It Cm W
The left edge of the monitor.
.It Cm C
The center of the monitor.
.It Cm E
The right edge of the monitor.
.It Cm SW
The lower-left corner of the monitor.
.It Cm S
The lower edge of the monitor.
.It Cm SE
The lower-right corner of the monitor.
.It Cm R
The initial static position of the window.
.It Cm L
The last position of the window.
.El
.Pp
Defaults:
.Dl Adwm* Ns Cm movetoSW Ns Li : Ar "AC + KP_1, AC + c : z"
.Dl Adwm* Ns Cm movetoS Ns Li : Ar "AC + KP_2, AC + c : b, AC + c : x"
.Dl Adwm* Ns Cm movetoSE Ns Li : Ar "AC + KP_3, AC + c : c, AC + c : m"
.Dl Adwm* Ns Cm movetoW Ns Li : Ar "AC + KP_4, AC + c : a"
.Dl Adwm* Ns Cm movetoC Ns Li : Ar "AC + KP_5, AC + c : h, AC + c : s"
.Dl Adwm* Ns Cm movetoE Ns Li : Ar "AC + KP_6, AC + c : d, AC + c : l"
.Dl Adwm* Ns Cm movetoNW Ns Li : Ar "AC + KP_7, AC + c : q"
.Dl Adwm* Ns Cm movetoN Ns Li : Ar "AC + KP_8, AC + c : w, AC + c : y"
.Dl Adwm* Ns Cm movetoNE Ns Li : Ar "AC + KP_9, AC + c : e, AC + c : p"
.Pp
.Dl Adwm* Ns Cm snaptoSW Ns Li : Ar "ACS + KP_1"
.Dl Adwm* Ns Cm snaptoS Ns Li : Ar "ACS + KP_2"
.Dl Adwm* Ns Cm snaptoSE Ns Li : Ar "ACS + KP_3"
.Dl Adwm* Ns Cm snaptoW Ns Li : Ar "ACS + KP_4"
.Dl Adwm* Ns Cm smartplace Ns Li : Ar "ACS + KP_5"
.Dl Adwm* Ns Cm snaptoE Ns Li : Ar "ACS + KP_6"
.Dl Adwm* Ns Cm snaptoNW Ns Li : Ar "ACS + KP_7"
.Dl Adwm* Ns Cm snaptoN Ns Li : Ar "ACS + KP_8"
.Dl Adwm* Ns Cm snaptoNE Ns Li : Ar "ACS + KP_9"
.Pp 
.Dl Adwm* Ns Cm edgetoE Ns Li : Ar "AC + c : S + d, AC + c : S + l"
.Dl Adwm* Ns Cm edgetoN Ns Li : Ar "AC + c : S + w, AC + c : S + y"
.Dl Adwm* Ns Cm edgetoS Ns Li : Ar "AC + c : S + b, AC + c : S + x"
.Dl Adwm* Ns Cm edgetoW Ns Li : Ar "AC + c : S + a"
.Pp 
.Dl Adwm* Ns Cm fillleft Ns Li : Ar "W + Left"
.Dl Adwm* Ns Cm fillright Ns Li : Ar "W + Right"
.It Cm <tagaction>[<suffix>] [tag|[+-]increment]
.Pp
.Cm <tagaction>
indicates the tag action to perform and
can be one of the following:
.Pp
.Bl -tag -width ".Cm toggleview" -compact
.It Cm view
View the corresponding tag on the current monitor.  This has the effect of changing to the
corresponding desktop/workspace.
.It Cm focusview
Switch to the view of the corresponding tag and focus the first window in the view.
.It Cm toggleview
Toggle viewing the corresponding tag on the current monitor.  This does not change
desktop/workspace, just changes which windows are shown on the current desktop/workspace.
.It Cm tag
Tag the selected window with the corresponding tag.  This has the effect of sending the window
to the desktop/workspace corresponding to the tag.
.It Cm toggletag
Toggle the corresponding tag on the selected window.  This affects on which desktops/workspaces
the window is displayed.
.It Cm taketo
Tag the selected window with only the corresponding tag and switch the view on the current monitor
to that of the tag.  This has the effect of taking the window to the desktop/workspace
corresponding to the tag.
.It Cm sendto
Tag the selected window with only the corresponding tag.  This has the effect of sending the window
to the desktop/workspace without following it.
.El
.Pp
The optional
.Cm <suffix>
is one of the following:
.Pp
.Bl -tag -width ".Cm right" -compact
.It Dq
.It Cm #
The tag index number,
.Cm # Ns ,
starting at 1.
.It Cm next
The next tag.
.It Cm prev
The previous tag.
.It Cm last
The previously selected tag.
.It Cm up
The tag above (w/o wrapping).
.It Cm down
The tag below (w/o wrapping).
.It Cm left
The tag to the left (w/o wrapping).
.It Cm right
The tag to the right (w/o wrapping).
.It Cm NW
The upper-left tag (wrapping).
.It Cm N
The upper tag (wrapping).
.It Cm NE
The upper-right tag (wrapping).
.It Cm W
The left tag (wrapping).
.It Cm E
The right tag (wrapping).
.It Cm SW
The lower-left tag (wrapping).
.It Cm S
The lower tag (wrapping).
.It Cm SE
The lower-right tag (wrapping).
.El
.Pp
Defaults:
.Dl Adwm* Ns Cm view0 Ns Li : Ar "A + 1, C + F1, W + 1"
.Dl Adwm* Ns Cm view1 Ns Li : Ar "A + 2, C + F2, W + 2"
.Dl Adwm* Ns Cm view2 Ns Li : Ar "A + 3, C + F3, W + 3"
.Dl Adwm* Ns Cm view3 Ns Li : Ar "A + 4, C + F4, W + 4"
.Dl Adwm* Ns Cm view4 Ns Li : Ar "A + 5, C + F5, W + 5"
.Dl Adwm* Ns Cm view5 Ns Li : Ar "A + 6, C + F6, W + 6"
.Dl Adwm* Ns Cm view6 Ns Li : Ar "A + 7, C + F7, W + 7"
.Dl Adwm* Ns Cm view7 Ns Li : Ar "A + 8, C + F8, W + 8"
.Dl Adwm* Ns Cm view8 Ns Li : Ar "A + 9, C + F9, W + 9"
.Dl Adwm* Ns Cm view9 Ns Li : Ar "A + 0, C + F10, W + 0"
.Dl Adwm* Ns Cm view10 Ns Li : Ar "A + bracketleft, C + F11"
.Dl Adwm* Ns Cm view11 Ns Li : Ar "A + bracketright, C + F12"
.Dl Adwm* Ns Cm viewnext Ns Li : Ar "AC + Right, W + Up"
.Dl Adwm* Ns Cm viewprev Ns Li : Ar "AC + Left, W + Down"
.Dl Adwm* Ns Cm viewlast Ns Li : Ar "W + Escape, WS + Up"
.Dl Adwm* Ns Cm viewup Ns Li : Ar "AC + Up, AC + k, W + Page_Up"
.Dl Adwm* Ns Cm viewdown Ns Li : Ar "AC + Down, AC + j, W + Page_Down"
.Dl Adwm* Ns Cm viewleft Ns Li : Ar "AC + h, W + Home"
.Dl Adwm* Ns Cm viewright Ns Li : Ar "AC + l, W + End"
.Pp
.Dl Adwm* Ns Cm toggleview0 Ns Li : Ar "AC + 1, WC + 1"
.Dl Adwm* Ns Cm toggleview1 Ns Li : Ar "AC + 2, WC + 2"
.Dl Adwm* Ns Cm toggleview2 Ns Li : Ar "AC + 3, WC + 3"
.Dl Adwm* Ns Cm toggleview3 Ns Li : Ar "AC + 4, WC + 4"
.Dl Adwm* Ns Cm toggleview4 Ns Li : Ar "AC + 5, WC + 5"
.Dl Adwm* Ns Cm toggleview5 Ns Li : Ar "AC + 6, WC + 6"
.Dl Adwm* Ns Cm toggleview6 Ns Li : Ar "AC + 7, WC + 7"
.Dl Adwm* Ns Cm toggleview7 Ns Li : Ar "AC + 8, WC + 8"
.Dl Adwm* Ns Cm toggleview8 Ns Li : Ar "AC + 9, WC + 9"
.Dl Adwm* Ns Cm toggleview9 Ns Li : Ar "AC + 0, WC + 0"
.Dl Adwm* Ns Cm toggleview10 Ns Li : Ar "AC + bracketleft, WC + bracketleft"
.Dl Adwm* Ns Cm toggleview11 Ns Li : Ar "AC + bracketright, WC + bracketright"
.Pp
.Dl Adwm* Ns Cm tag0 Ns Li : Ar "AS + 1"
.Dl Adwm* Ns Cm tag1 Ns Li : Ar "AS + 2"
.Dl Adwm* Ns Cm tag2 Ns Li : Ar "AS + 3"
.Dl Adwm* Ns Cm tag3 Ns Li : Ar "AS + 4"
.Dl Adwm* Ns Cm tag4 Ns Li : Ar "AS + 5"
.Dl Adwm* Ns Cm tag5 Ns Li : Ar "AS + 6"
.Dl Adwm* Ns Cm tag6 Ns Li : Ar "AS + 7"
.Dl Adwm* Ns Cm tag7 Ns Li : Ar "AS + 8"
.Dl Adwm* Ns Cm tag8 Ns Li : Ar "AS + 9"
.Dl Adwm* Ns Cm tag9 Ns Li : Ar "AS + 0"
.Dl Adwm* Ns Cm tag10 Ns Li : Ar "AS + bracketleft"
.Dl Adwm* Ns Cm tag11 Ns Li : Ar "AS + bracketright"
.Pp
.Dl Adwm* Ns Cm toggletag0 Ns Li : Ar "ACS + 1, WCS + 1"
.Dl Adwm* Ns Cm toggletag1 Ns Li : Ar "ACS + 2, WCS + 2"
.Dl Adwm* Ns Cm toggletag2 Ns Li : Ar "ACS + 3, WCS + 3"
.Dl Adwm* Ns Cm toggletag3 Ns Li : Ar "ACS + 4, WCS + 4"
.Dl Adwm* Ns Cm toggletag4 Ns Li : Ar "ACS + 5, WCS + 5"
.Dl Adwm* Ns Cm toggletag5 Ns Li : Ar "ACS + 6, WCS + 6"
.Dl Adwm* Ns Cm toggletag6 Ns Li : Ar "ACS + 7, WCS + 7"
.Dl Adwm* Ns Cm toggletag7 Ns Li : Ar "ACS + 8, WCS + 8"
.Dl Adwm* Ns Cm toggletag8 Ns Li : Ar "ACS + 9, WCS + 9"
.Dl Adwm* Ns Cm toggletag9 Ns Li : Ar "ACS + 0, WCS + 0"
.Dl Adwm* Ns Cm toggletag10 Ns Li : Ar "ACS + bracketleft, WCS + bracketleft"
.Dl Adwm* Ns Cm toggletag11 Ns Li : Ar "ACS + bracketright, WCS + bracketright"
.Pp
.Dl Adwm* Ns Cm sendto0 Ns Li : Ar "W + F1, WS + 1"
.Dl Adwm* Ns Cm sendto1 Ns Li : Ar "W + F2, WS + 2"
.Dl Adwm* Ns Cm sendto2 Ns Li : Ar "W + F3, WS + 3"
.Dl Adwm* Ns Cm sendto3 Ns Li : Ar "W + F4, WS + 4"
.Dl Adwm* Ns Cm sendto4 Ns Li : Ar "W + F5, WS + 5"
.Dl Adwm* Ns Cm sendto5 Ns Li : Ar "W + F6, WS + 6"
.Dl Adwm* Ns Cm sendto6 Ns Li : Ar "W + F7, WS + 7"
.Dl Adwm* Ns Cm sendto7 Ns Li : Ar "W + F8, WS + 8"
.Dl Adwm* Ns Cm sendto8 Ns Li : Ar "W + F9, WS + 9"
.Dl Adwm* Ns Cm sendto9 Ns Li : Ar "W + F10, WS + 0"
.Dl Adwm* Ns Cm sendto10 Ns Li : Ar "W + F11, WS + F1"
.Dl Adwm* Ns Cm sendto11 Ns Li : Ar "W + F12, WS + F2"
.Dl Adwm* Ns Cm sendto12 Ns Li : Ar "WS + F3"
.Dl Adwm* Ns Cm sendto13 Ns Li : Ar "WS + F4"
.Dl Adwm* Ns Cm sendto14 Ns Li : Ar "WS + F5"
.Dl Adwm* Ns Cm sendto15 Ns Li : Ar "WS + F6"
.Dl Adwm* Ns Cm sendto16 Ns Li : Ar "WS + F7"
.Dl Adwm* Ns Cm sendto17 Ns Li : Ar "WS + F8"
.Dl Adwm* Ns Cm sendto18 Ns Li : Ar "WS + F9"
.Dl Adwm* Ns Cm sendto19 Ns Li : Ar "WS + F10"
.Dl Adwm* Ns Cm sendto20 Ns Li : Ar "WS + F11"
.Dl Adwm* Ns Cm sendto21 Ns Li : Ar "WS + F12"
.Dl Adwm* Ns Cm sendtoup Ns Li : Ar "AS + Up"
.Dl Adwm* Ns Cm sendtodown Ns Li : Ar "AS + Down"
.Dl Adwm* Ns Cm sendtoleft Ns Li : Ar "AS + Left"
.Dl Adwm* Ns Cm sendtoright Ns Li : Ar "AS + Right"
.Pp
.Dl Adwm* Ns Cm taketo0 Ns Li : Ar "WC + F1"
.Dl Adwm* Ns Cm taketo1 Ns Li : Ar "WC + F2"
.Dl Adwm* Ns Cm taketo2 Ns Li : Ar "WC + F3"
.Dl Adwm* Ns Cm taketo3 Ns Li : Ar "WC + F4"
.Dl Adwm* Ns Cm taketo4 Ns Li : Ar "WC + F5"
.Dl Adwm* Ns Cm taketo5 Ns Li : Ar "WC + F6"
.Dl Adwm* Ns Cm taketo6 Ns Li : Ar "WC + F7"
.Dl Adwm* Ns Cm taketo7 Ns Li : Ar "WC + F8"
.Dl Adwm* Ns Cm taketo8 Ns Li : Ar "WC + F9"
.Dl Adwm* Ns Cm taketo9 Ns Li : Ar "WC + F10"
.Dl Adwm* Ns Cm taketo10 Ns Li : Ar "WC + F11"
.Dl Adwm* Ns Cm taketo11 Ns Li : Ar "WC + F12"
.Dl Adwm* Ns Cm taketonext Ns Li : Ar "ACS + Right, W + a, WC + Right"
.Dl Adwm* Ns Cm taketoprev Ns Li : Ar "ACS + Left, WC + Left, WS + Down"
.Dl Adwm* Ns Cm taketoup Ns Li : Ar "ACS + Up, WC + Up, WS + Page_Up"
.Dl Adwm* Ns Cm taketodown Ns Li : Ar "ACS + Down, WC + Down, WS + Page_Down"
.Dl Adwm* Ns Cm taketoleft Ns Li : Ar "WS + Home"
.Dl Adwm* Ns Cm taketoright Ns Li : Ar "WS + End"
.Pp
Defaults:
.Dl Adwm* Ns Cm scrto0 Ns Li : Ar "WS + KP_1"
.Dl Adwm* Ns Cm scrto1 Ns Li : Ar "WS + KP_2"
.Dl Adwm* Ns Cm scrto2 Ns Li : Ar "WS + KP_3"
.Dl Adwm* Ns Cm scrto3 Ns Li : Ar "WS + KP_4"
.Dl Adwm* Ns Cm scrto4 Ns Li : Ar "WS + KP_5"
.Dl Adwm* Ns Cm scrto5 Ns Li : Ar "WS + KP_6"
.Dl Adwm* Ns Cm scrto6 Ns Li : Ar "WS + KP_7"
.Dl Adwm* Ns Cm scrto7 Ns Li : Ar "WS + KP_8"
.Dl Adwm* Ns Cm scrto8 Ns Li : Ar "WS + KP_9"
.Dl Adwm* Ns Cm scrtonext Ns Li : Ar "AS + period, W + o"
.Dl Adwm* Ns Cm scrtoprev Ns Li : Ar "AS + comma"
.It Cm [<prefix>]<cycle>[<suffix>][<range>]
Cycles focus or selection through windows sharing some characteristics.
.Pp
.Cm <cycle>
specifies the action to perform and the range of windows on which the action may be performed
and is one of the following:
.Bl -tag -width ".Cm client" -compact -offset indent
.It Cm focus
Select
client, tiled order.
.It Cm client
Select
client, client list order.
.It Cm stack
Select
client, stacking order.
.It Cm group
Select
client of same class, tiled order.
.It Cm tab
Select
client tab, tab order.
.It Cm panel
Select
panels, tiled order.
.It Cm dock
Select
dock applications, tiled order.
.It Cm swap
Swap with other
client, tiled order.
.El
.Pp
The optional
.Cm <prefix>
indicates the form of cycling and can be one of the following:
.Bl -tag -width ".Cm right" -compact -offset indent
.It Dq
The window is selected immediately once the key is pressed and the cycle completes.
.It Cm cycle
The window is selected immediately once the key is pressed, however, the cycle does not complete
until a modifier key is pressed or released or a new key is pressed.  This form also displays a
cycle window (available window list) while the cycle is active.
.El
.Pp
The optional
.Cm <suffix>
indicates which client to select and is one of the following:
.Bl -tag -width ".Cm urgent" -compact -offset indent
.It Dq
Select window by tag argument (beginning at 1).
.It Cm #
Select window by index (beginning at 0).
.It Cm main
Select the master window (focus only).
.It Cm urgent
Select next urgent window (focus only).
.It Cm icon
Select next iconified window in order.
.It Cm next
Select next window in order.
.It Cm prev
Select previous window in order.
.It Cm last
Select last selected window.
.It Cm up
Select window above.
.It Cm down
Select window below.
.It Cm left
Select window to the left.
.It Cm right
Select window to the right.
.It Cm NW
Select window above and to the left.
.It Cm N
Select window above.
.It Cm NE
Select window above and to the right.
.It Cm W
Select window to the left.
.It Cm E
Select window to the right.
.It Cm SW
Select window below and to the left.
.It Cm S
Select window below.
.It Cm SE
Select window below and to the right.
.El
.Pp
A optional
.Cm <range>
indicates the range of clients to make available for selection and is one of the following:
.Bl -tag -width ".Cm every" -compact -offset indent
.It Dq
All focusable windows displayed on the current monitor.
.It Cm act
All windows on the current monitor that can be activated regarless of whether they can be
focused or not and regardless of whether they are iconified or hidden or not.
.It Cm all
All windows on the current monitor.
.It Cm all
All windows on any monitor.
.It Cm every
All windows in any view.
.El
.Pp
Defaults:
.Dl Adwm* Ns Cm focusnext Ns Li : Ar "A + j, A + Escape, A + Tab, W + Tab, W + j"
.Dl Adwm* Ns Cm focusprev Ns Li : Ar "A + k, AS + Escape, AS + Tab, W + k, WS + Tab"
.Dl Adwm* Ns Cm focusurgent Ns Li : Ar "W + u"
.Dl Adwm* Ns Cm groupnext Ns Li : Ar "A + grave, A + F6, W + grave"
.Dl Adwm* Ns Cm groupprev Ns Li : Ar "AS + grave, AS + F6, WS + grave"
.Dl Adwm* Ns Cm panelnext Ns Li : Ar "AC + Escape"
.Dl Adwm* Ns Cm panelprev Ns Li : Ar "ACS + Escape"
.Dl Adwm* Ns Cm docknext Ns Li : Ar "AC + Tab"
.Dl Adwm* Ns Cm dockprev Ns Li : Ar "ACS + Tab"
.Dl Adwm* Ns Cm swapnext Ns Li : Ar "WS + j"
.Dl Adwm* Ns Cm swapprev Ns Li : Ar "WS + k"
.Pp
.It Cm setlayout<c>
Set the monitor layout for the current monintor to the specified layout,
.Cm <c> ,
where
.Cm <c>
is one of the following:
.Pp
.Bl -tag -width ".Cm i , f" -compact
.It Cm m
.Dq monacle
showing one window at a time.
.It Cm f , i
.Dq floating
stacked windows.
.It Cm t
.Dq tiled
with master left and stacking right.
.It Cm b
.Dq tiled
with master on bottom and stacking on top.
.It Cm l
.Dq tiled
with master right and stacking left.
.It Cm u
.Dq tiled
with master on top and stacking on bottom.
.It Cm g
.Dq grid
with windows in rows and columns.
.El
.Pp
Defaults:
.Dl Adwm* Ns Cm setlayoutm Ns : Ar "A + m"
.Dl Adwm* Ns Cm setlayoutf Ns : Ar "A + f"
.Dl Adwm* Ns Cm setlayouti Ns : Ar "A + i"
.Dl Adwm* Ns Cm setlayoutt Ns : Ar "A + r"
.Dl Adwm* Ns Cm setlayoutb Ns : Ar "A + w"
.Dl Adwm* Ns Cm setlayoutl Ns : Ar "A + t"
.Dl Adwm* Ns Cm setlayoutu Ns : Ar "A + u"
.Dl Adwm* Ns Cm setlayoutg Ns : Ar "A + g"
.Pp
.It Cm layout Ns Li { Ns Cm next Ns Li | Ns Cm prev Ns Li }
Cycle the current monitor layout to the next or previous available
layout.  This is for compatibility with
.Xr awesome 1 ,
.Xr dwm 1 ,
.Xr spectrwm 1 ,
.Xr velox 1 ,
.Xr xdwm 1 .
.Pp
Defaults:
.Dl Adwm* Cm layoutnext Ns Li : Ar "W + space"
.Dl Adwm* Cm layoutprev Ns Li : Ar "WS + space"
.Pp
.Sy Note:
These functions are not currently implemented.
(See
.Pa TODO Ns ).
.It Cm arrange Ns Li [ Ns Cm icons Ns Li ]
Rearranges windows in floating modes (or icons, when specified). This is
for compatibility with
.Xr icewm 1 .
.Nm @PACKAGE@
does not support icons on the desktop directly, so the
.Cm arrangeicons
function is not implemented.
.Pp
Defaults:
.Dl Adwm* Ns Cm arrange Ns Li : Ar "AS + F5"
.Dl Adwm* Ns Cm arrangeicons Ns Li : Ar "AS + F8"
.Pp
.Sy Note:
These functions are not currently implemented.
(See
.Pa TODO Ns ).
.It Cm togglefocus
Toggles the focus between the currently focused window and the
previous focused window.
This is for compatibility with 
.Xr velox 1 .
.Sy Note:
This function is not currently implemented.
(See
.Pa TODO Ns ).
.It Cm spawn<n> Ar shell-command
Spawns the n'th command argument.
.Cm <n>
can be from 0 to 63.
.Pp
Defaults:
.Dl Adwm* Ns Cm spawn0 Ns Li : Ar "AC + t = xdg-launch roxterm"
.Dl Adwm* Ns Cm spawn1 Ns Li : Ar "AC + w = xdg-launch firefox"
.Dl Adwm* Ns Cm spawn2 Ns Li : Ar "AC + f = xdg-launch pcmanfm"
.Dl Adwm* Ns Cm spawn3 Ns Li : Ar "AC + r = xde-run"
.Dl Adwm* Ns Cm spawn4 Ns Li : Ar "AC + v = xdg-launch gvim"
.Dl Adwm* Ns Cm spawn5 Ns Li : Ar "AC + n = xdg-launch uxterm"
.Dl Adwm* Ns Cm spawn6 Ns Li : Ar "AC + m = xde-menu -P"
.Dl Adwm* Ns Cm spawn7 Ns Li : Ar "A + space = xde-winmenu -w active -W center"
.Dl Adwm* Ns Cm spawn8 Ns Li : Ar "A + F1 = xdg-launch uxterm"
.Dl Adwm* Ns Cm spawn9 Ns Li : Ar "A + F2 = xde-run"
.Dl Adwm* Ns Cm spawn10 Ns Li : Ar "A + Print = scrot -s"
.Dl Adwm* Ns Cm spawn11 Ns Li : Ar "A + x = xdg-launch uxterm"
.Dl Adwm* Ns Cm spawn12 Ns Li : Ar "AC + Delete = xde-logout"
.Dl Adwm* Ns Cm spawn13 Ns Li : Ar "AC + Return = xdg-launch uxterm"
.Dl Adwm* Ns Cm spawn14 Ns Li : Ar "AC + e : c = xde-run"
.Dl Adwm* Ns Cm spawn15 Ns Li : Ar "AC + e : e = xdg-launch uxterm"
.Dl Adwm* Ns Cm spawn16 Ns Li : Ar "AC + e : l = xdg-launch xde-xlock"
.Dl Adwm* Ns Cm spawn17 Ns Li : Ar "AC + e : s = scrot -s"
.Dl Adwm* Ns Cm spawn18 Ns Li : Ar "AC + p : d = xde-run"
.Dl Adwm* Ns Cm spawn19 Ns Li : Ar "AC + x = xdg-launch uxterm"
.Dl Adwm* Ns Cm spawn20 Ns Li : Ar "AS + Return = xdg-launch uxterm"
.Dl Adwm* Ns Cm spawn21 Ns Li : Ar "C + Escape = xde-menu -P"
.Dl Adwm* Ns Cm spawn22 Ns Li : Ar "F11 = xde-winlist"
.Dl Adwm* Ns Cm spawn23 Ns Li : Ar "F12 = xde-menu -P"
.Dl Adwm* Ns Cm spawn24 Ns Li : Ar "S + Escape = xde-winmenu -w active -W center"
.Dl Adwm* Ns Cm spawn25 Ns Li : Ar "W + e = xdg-launch pcmanfm"
.Dl Adwm* Ns Cm spawn26 Ns Li : Ar "W + p = xde-menu -P"
.Dl Adwm* Ns Cm spawn27 Ns Li : Ar "W + r = xde-run"
.Dl Adwm* Ns Cm spawn28 Ns Li : Ar "W + s = scrot"
.Dl Adwm* Ns Cm spawn29 Ns Li : Ar "W + slash = xde-findws"
.Dl Adwm* Ns Cm spawn30 Ns Li : Ar "WS + Delete = xdg-launch xde-xlock"
.Dl Adwm* Ns Cm spawn31 Ns Li : Ar "WS + Return = xdg-launch uxterm"
.Dl Adwm* Ns Cm spawn32 Ns Li : Ar "WS + s = scrot -s"
.Dl Adwm* Ns Cm spawn33 Ns Li : Ar "WS + slash = xde-namews"
.Dl Adwm* Ns Cm spawn34 Ns Li : Ar "XF86MonBrightnessUp = xbrightness +4096"
.Dl Adwm* Ns Cm spawn35 Ns Li : Ar "XF86MonBrightnessDown = xbrightness -4096"
.Dl Adwm* Ns Cm spawn36 Ns Li : Ar "C + XF86MonBrightnessUp = xbacklight -inc 5"
.Dl Adwm* Ns Cm spawn37 Ns Li : Ar "C + XF86MonBrightnessDown = xbacklight -dec 5"
.Dl Adwm* Ns Cm spawn38 Ns Li : Ar "XF86AudioRaiseVolume = amixer sset Master\\,0 5%+"
.Dl Adwm* Ns Cm spawn39 Ns Li : Ar "XF86AudioLowerVolume = amixer sset Master\\,0 5%-"
.Dl Adwm* Ns Cm spawn40 Ns Li : Ar "XF86AudioMute = amixer sset Master\\,0 toggle"
.Dl Adwm* Ns Cm spawn41 Ns Li : Ar "CWA + Left = xrandr -o left"
.Dl Adwm* Ns Cm spawn42 Ns Li : Ar "CWA + Right = xrandr -o right"
.Dl Adwm* Ns Cm spawn43 Ns Li : Ar "CWA + Down = xrandr -o inverted"
.Dl Adwm* Ns Cm spawn44 Ns Li : Ar "CWA + Up = xrandr -o normal"
.Pp
.It Cm command Ar shell-command
This is not a key binding.  It specifies a command, 
.Ar shell-command ,
to execute when a mouse button is pressed on the root window.  The default pops an
XDG root menu.
.Pp
Note that additional keybindings with commands can be specified on the
same line following a comma, commas in commands must be escaped with
two backslashes (one for xrdb and one for @PACKAGE@).
.Pp
Default:
.Li Adwm* Ns Cm command Ns : Ar "xdg-traymenu -p -b 1"
.El
.Sh DEFAULTS
The default key bindings are provided in the default key file,
.Pa @pkgconfdir@/keysrc ,
but may be overridden by the style (e.g. the default style located in
.Pa @pkgconfdir@/styles/default/keysrc )
and ultimately overridden by keys specified by the user in the user
file (typically located in
.Pa ~/.@PACKAGE@/keysrc Ns ).
.Pp
The defaults are, in general, very vim-like in key binding and effect (but, of course,
must include a modifier different from vim unless you want to lose all vim
functionality).  Also, most window managers based on
.Xr dwm 1
follow a common thread of defaults.
.Pp
So that users of other window managers and systems do not have problems initially
using
.Xr @PACKAGE@ 1
before they get used to the more advance key bindings, a full set of
Gnome2/Windows95-like key bindings are also provided.  Specific default key bindings
for advanced features provided by some window managers (such as
.Xr openbox 1 ,
.Xr pekwm 1 ,
.Xr blackbox 1 ,
.Xr fluxbox 1 ,
.Xr icewm 1 )
are also provided to smooth transition, or to make
.Xr @PACKAGE@ 1
immediately usable to these users as well.
.Sh FILES
.Pp
.Bl -tag -width "XX"
.It Cm $(dirname <themeFile>) Ns Ar /keysrc
Default location of the keys file when a theme is defined.
.It Cm $(dirname <styleFile>) Ns Ar /keysrc
Default location of the keys file when a style is defined.
.It Cm ${ADWMPRIVDIR} Ns Ar /keysrc
Location of the user private keys file.
.It Cm ${XDG_RUNTIME_DIR} Ns Ar /@PACKAGE@/keysrc
Location of the user runtime keys file.
.It Cm ${XDG_CONFIG_HOME} Ns Ar /@PACKAGE@/keysrc
Location of the user XDG keys file.
.It Cm ${HOME} Ns Ar /.@PACKAGE@/keysrc
Location of the user keys file.
.It Ar @pkgconfdir@/keysrc
Location of the system keys file.
.El
.Sh SEE ALSO
.Rs
.Xr @PACKAGE@ 1 ,
.Xr @PACKAGE@-config 5 ,
.Xr spectrwm 1 ,
.Xr dwm 1 ,
.Xr openbox 1 ,
.Xr pekwm 1 ,
.Xr blackbox 1 ,
.Xr fluxbox 1 ,
.Xr icewm 1 .
.Re
.Sh BUGS
No outstanding bugs.
.Sh HISTORY
.Sh AUTHORS
.An Brian Bidulock Aq bidulock@openss7.org
.Sh LICENSE
.Nm @PACKAGE_NAME@
is licensed under the GNU General Public License Version 3 or later.
.sp
See the
.Pa COPYING
file in the distribution.
.\" vim: set ft=nroff sw=4 et nocin tw=72 spell:
